#!/usr/bin/env python
# encoding: utf-8

"""
File containing functionality related to build statistics.

This file injects itself into the waf build process and extract various data.
This data is located in the root of the build folder as a json file named
build_statistics.json.
Finally a summary is printed if any non-trivial changes occured.
"""

from waflib import TaskGen
from waflib import Logs
import time
import json
import os

filename = 'build_statistics.json'

old_build_statistics = {}
new_build_statistics = {}


@TaskGen.feature('*')
@TaskGen.before_method('process_source')
def get_data(self):
    """
    Read past build statistics.

    Before processing any sources read the past build statistics.
    """
    if not old_build_statistics:
        f = os.path.join(self.bld.bldnode.srcpath(), filename)
        if os.path.exists(f):
            with open(f) as data_file:
                old_build_statistics.update(json.load(data_file))


@TaskGen.feature('*')
@TaskGen.after_method('process_source')
def collect_data_from_tasks(self):
    """
    Wrap tasks to collect information from them.

    This function wraps each task with the collect_data_from_run function so
    that the needed data is collected.
    """
    tasks = []
    if hasattr(self, 'compiled_tasks'):
        tasks = self.compiled_tasks

    if hasattr(self, 'link_task'):
        tasks.append(self.link_task)

    for task in tasks:
        task.run = collect_data_from_run(task.run, task)
        for output in task.outputs:
            new_build_statistics[output.bldpath()] = {}

    if 'post_funs' not in dir(self.bld) or get_sizes not in self.bld.post_funs:
        self.bld.add_post_fun(get_sizes)

    if 'post_funs' not in dir(self.bld) or save_data not in self.bld.post_funs:
        self.bld.add_post_fun(save_data)


def get_sizes(self):
    """Collect sizes of all output generated by tasks."""
    tasks = []
    for group in self.groups:
        for task_gen in group:
            tasks += task_gen.tasks

    for task in tasks:
        for output in task.outputs:
            key = output.bldpath()
            value = os.path.getsize(output.srcpath()) / 1024.0
            new_build_statistics[key]['size'] = {'value': value, 'unit': 'kb'}


def collect_data_from_run(f, task):
    """Collect compile time from task."""
    def wrap_run():
        start = time.time()
        return_value = f()
        stop = time.time()
        for output in task.outputs:
            key = output.bldpath()
            value = (stop - start)
            new_build_statistics[key]['time'] = {'value': value, 'unit': 's'}

        return return_value
    return wrap_run


def save_data(self):
    """
    Save the collected data to a json file.

    This function writes all the collected data to a file, and, if any changes
    happened, writes a summary.
    """
    build_statistics = {}

    for k in new_build_statistics:
        if k not in old_build_statistics:
            build_statistics[k] = new_build_statistics[k]
            continue

        build_statistics[k] = old_build_statistics[k].copy()
        build_statistics[k].update(new_build_statistics[k])

    compare_stats = old_build_statistics
    compare_with = 'previous build'

    if self.has_tool_option('compare_with'):
        compare_with = self.get_tool_option('compare_with')
        if os.path.exists(compare_with):
            with open(compare_with) as data_file:
                compare_stats = json.load(data_file)
        else:
            compare_stats = {}
            Logs.warn('{} does not exists.'.format(compare_with))

    if compare_stats:
        summaries = generate_summaries(compare_stats, build_statistics)
        print_summaries(summaries)

    f = os.path.join(self.bldnode.srcpath(), filename)
    with open(f, 'w') as outfile:
        json.dump(build_statistics, outfile)


def generate_summaries(a, b):
    """Generate data summarising the changes between the a and b dict."""
    summaries = []

    # removed
    for key in set(a) - set(b):
        summary = generate_removed_summary(key, a)
        summaries.append(summary)

    # added
    for key in set(b) - set(a):
        summary = generate_added_summary(key, b)
        summaries.append(summary)

    # changed
    for key in set(a) & set(b):
        summary = generate_changed_summary(key, a, b)

        # only include if something actually changed.
        if any([r['difference'] != 0 for r in summary['results'].values()]):
            summaries.append(summary)

    return summaries


def generate_changed_summary(key, a, b):
    """Generate summary for files changed."""
    result = {'file': key, 'state': 'changed'}
    a = a[key]
    b = b[key]
    result['results'] = {}
    for stat in set(a) & set(b):
        a_stat = a[stat]
        b_stat = b[stat]
        assert a_stat['unit'] == b_stat['unit']

        difference = b_stat['value'] - a_stat['value']
        percent = difference / a_stat['value'] * 100
        result['results'][stat] = {
            'unit':  b_stat['unit'],
            'value': b_stat['value'],
            'value_old': a_stat['value'],
            'difference': difference,
            'percent': percent
        }

    return result


def generate_removed_summary(key, a):
    """Generate summary for files removed."""
    result = {'file': key, 'state': 'removed'}
    a = a[key]
    result['results'] = {}
    for stat in a:
        a_stat = a[stat]
        result['results'][stat] = {
            'unit': a_stat['unit'],
            'value': 0,
            'value_old': a_stat['value'],
            'difference': -a_stat['value']
        }

    return result


def generate_added_summary(key, b):
    """Generate summary for files added."""
    result = {'file': key, 'state': 'added'}
    b = b[key]
    result['results'] = {}
    for stat in b:
        b_stat = b[stat]
        result['results'][stat] = {
            'unit':  b_stat['unit'],
            'value': b_stat['value'],
            'value_old': 0,
            'difference': b_stat['value']
        }

    return result


def print_results(results):
    """Print result set."""
    for stat, result in results.items():
        message = ('[ RESULT ]  {stat}   old {value_old:0.3f} {unit}\n'
                   '[        ]         new {value:0.3f} {unit}\n'
                   '[        ]  difference {difference:0.3f} {unit}')

        if 'percent' in result:
            message += ' ({percent:0.3f} %)'

        color = 'CYAN'
        if result['difference'] > 0:
            color = 'PINK'

        Logs.pprint(color, message.format(stat=stat, **result))


def print_summaries(summaries):
    """Print total and general summaries nicely."""
    total_summary = None
    total_state = {'removed': 0, 'added': 0, 'changed': 0}
    for summary in summaries:
        # print summary
        Logs.pprint('BOLD', '[ FILE   ] {file} ({state})'.format(**summary))
        results = summary['results']
        print_results(results)

        # maintain total summary
        total_state[summary['state']] += 1
        if total_summary is None:
            total_summary = {k: {'value': 0, 'value_old': 0} for k in results}
        for stat in total_summary.keys():
            # if, for some reason, the total summary's results contains an
            # attribute not available for this set of results, we consider that
            # attribute void and remove it from the total summary.
            # E.g. if this output is missing the compile time, we cannot say
            # anything about the total compile time.
            if not any([stat == r for r in results]):
                total_summary.pop(stat)
                continue
            total_summary[stat]['unit'] = results[stat]['unit']
            total_summary[stat]['value'] += results[stat]['value']
            total_summary[stat]['value_old'] += results[stat]['value_old']

    if total_summary:
        total_state = \
            'changed: {changed}, added: {added}, removed: {removed}'.format(
                **total_state)

        Logs.pprint('BOLD', '[ TOTAL  ] {}'.format(total_state))
        for result in total_summary.keys():
            total_result = total_summary[result]
            total_result['difference'] = \
                total_result['value'] - total_result['value_old']
            total_result['percent'] = \
                total_result['difference'] / total_result['value_old'] * 100
        print_results(total_summary)
